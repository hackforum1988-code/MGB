-- PlotPersistence.lua (ModuleScript in ServerScriptService)
-- Speichert Gold + Brainrots pro Slot. StoredInSlot = slot.Name.
-- Überarbeitet: rekursive Prüfungen, defensive Restore, keine goto-Labels

local DataStoreService = game:GetService("DataStoreService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

local PlotPersistence = {}
local DATASTORE_NAME = "PlayerPlots_v1"
local ds = nil

local function tryGetDataStore()
	if ds then return ds end
	local inStudio = RunService:IsStudio()
	if inStudio then
		pcall(function() ds = DataStoreService:GetDataStore(DATASTORE_NAME) end)
		return ds
	else
		ds = DataStoreService:GetDataStore(DATASTORE_NAME)
		return ds
	end
end

local SAVE_RETRIES = 5
local RETRY_BASE_DELAY = 0.25

local function retryAsync(fn, retries)
	retries = retries or SAVE_RETRIES
	local delayTime = RETRY_BASE_DELAY
	for i = 1, retries do
		local ok, res = pcall(fn)
		if ok then
			return true, res
		end
		task.wait(delayTime)
		delayTime *= 2
	end
	return false, "max retries exceeded"
end

-- Build payload
function PlotPersistence:BuildSaveForPlayer(player)
	local out = { Plots = {}, Gold = 0, Updated = os.time() }

	if player and player:FindFirstChild("leaderstats") then
		local gold = player.leaderstats:FindFirstChild("Gold")
		if gold and gold:IsA("IntValue") then
			out.Gold = gold.Value
		end
	end

	local plotsFolder = workspace:FindFirstChild("Plots")
	if not plotsFolder then
		warn("PlotPersistence: workspace.Plots fehlt; kein Plot-Save möglich.")
		return out
	end

	for _, plot in ipairs(plotsFolder:GetChildren()) do
		if plot and plot:IsA("Instance") then
			local ownerAttr = plot:GetAttribute("Owner")
			if ownerAttr == player.Name then
				local plotData = { Slots = {} }

				for _, slot in ipairs(plot:GetChildren()) do
					local isSlot = false
					if type(slot.Name) == "string" and slot.Name:match("^Slot") then
						isSlot = true
					elseif slot:GetAttribute("IsSlot") == true then
						isSlot = true
					elseif slot:FindFirstChild("SlotMarker") then
						isSlot = true
					end

					if isSlot then
						-- DEBUG: show which slot we are scanning
						print("DEBUG SaveScan: player=", player.Name, "plot=", plot.Name, "slot=", slot.Name)

						local brainrotsFolder = workspace:FindFirstChild("Brainrots")
						local found = nil
						if brainrotsFolder then
							-- robust: rekursiv alle Descendants prüfen, nur Models berücksichtigen
							for _, obj in ipairs(brainrotsFolder:GetDescendants()) do
								if obj:IsA("Model") then
									local storedTag = obj:FindFirstChild("StoredInSlot")
									-- DEBUG: list brainrot candidate and its StoredInSlot if any
									print("DEBUG SaveScan: candidate:", obj.Name, "parent:", obj.Parent and obj.Parent:GetFullName() or "nil", "StoredInSlot:", (storedTag and storedTag.Value) or "nil", "Owner:", (obj:FindFirstChild("Owner") and obj.Owner.Value) or "nil")
									if storedTag and storedTag:IsA("StringValue") and storedTag.Value == slot.Name then
										found = obj
										break
									end
								end
							end
						end

						if found then
							print("DEBUG SaveScan: MATCH found for slot", slot.Name, "->", found.Name, "storedTag:", found:FindFirstChild("StoredInSlot") and found.StoredInSlot.Value or "nil")
							-- Defensive: only set slot entry once
							if not plotData.Slots[slot.Name] then
								local mining = found:FindFirstChild("MiningPower") and found.MiningPower.Value or nil
								local rarity = found:FindFirstChild("Rarity") and found.Rarity.Value or nil
								local price = found:FindFirstChild("Price") and found.Price.Value or nil
								local income = found:FindFirstChild("IncomePerSec") and found.IncomePerSec.Value or nil

								plotData.Slots[slot.Name] = {
									ModelName = found.Name,
									Rarity = rarity,
									MiningPower = mining,
									Price = price,
									IncomePerSec = income,
									StoredAt = slot.Name,
								}
							else
								print("PlotPersistence: Warnung - doppelter Eintrag für", slot.Name, "übersprungen")
							end
						else
							print("DEBUG SaveScan: NO match for slot", slot.Name)
						end
					end
				end

				out.Plots[plot.Name] = plotData
			end
		end
	end

	local okEnc, summary = pcall(function()
		return HttpService:JSONEncode({
			Player = player.Name,
			Gold = out.Gold,
			HasPlots = (out.Plots and next(out.Plots) ~= nil),
		})
	end)
	if okEnc then
		print("PlotPersistence: BuildSaveForPlayer summary:", summary)
	end

	return out
end

function PlotPersistence:SavePlayer(player)
	if not player or not player.UserId then return false, "invalid player" end
	local key = "player_" .. tostring(player.UserId)
	local payload = self:BuildSaveForPlayer(player)

	-- DEBUG: print payload summary before saving
	local okJson, payloadJson = pcall(function() return HttpService:JSONEncode(payload) end)
	if okJson then
		print("DEBUG SavePayload for", player.Name, payloadJson)
	else
		print("DEBUG SavePayload: could not encode payload for", player.Name)
	end

	local datastore = tryGetDataStore()
	if not datastore then
		warn("PlotPersistence: DataStore unavailable. Skipping save for", player.Name)
		return false, "datastore unavailable"
	end

	local ok, err = retryAsync(function()
		return datastore:UpdateAsync(key, function(old)
			if not old then
				return payload
			end
			old.Plots = payload.Plots
			old.Gold = payload.Gold
			old.Updated = payload.Updated
			return old
		end)
	end)

	if not ok then
		warn("PlotPersistence: Save failed for", player.Name, err)
		return false, err
	end
	print("PlotPersistence: SavePlayer success for", player.Name)
	return true
end

function PlotPersistence:LoadPlayer(player)
	if not player or not player.UserId then return nil, "invalid player" end
	local key = "player_" .. tostring(player.UserId)

	local datastore = tryGetDataStore()
	if not datastore then
		warn("PlotPersistence: DataStore unavailable. Skipping load for", player.Name)
		return nil, "datastore unavailable"
	end

	local success, data = retryAsync(function()
		return datastore:GetAsync(key)
	end)
	if not success then
		warn("PlotPersistence: Load failed for", player.Name)
		return nil, "load failed"
	end
	print("PlotPersistence: LoadPlayer returned data for", player.Name, "hasPlots=", (data and data.Plots and next(data.Plots) ~= nil))
	return data
end

-- Robuste RestorePlayer ohne goto
function PlotPersistence:RestorePlayer(player, spawnCallback, startIncomeCallback)
	local data, err = self:LoadPlayer(player)
	if not data then
		return false, err
	end

	if data.Gold and player and player:FindFirstChild("leaderstats") then
		local goldVal = player.leaderstats:FindFirstChild("Gold")
		if goldVal and goldVal:IsA("IntValue") then
			pcall(function() goldVal.Value = tonumber(data.Gold) or goldVal.Value end)
		end
	end

	if not data.Plots then return true end

	for plotName, plotData in pairs(data.Plots) do
		local plot = workspace:FindFirstChild("Plots") and workspace.Plots:FindFirstChild(plotName)
		if plot then
			plot:SetAttribute("Owner", player.Name)
			for slotName, slotInfo in pairs(plotData.Slots or {}) do
				if slotInfo and slotInfo.ModelName then
					-- Defensive: skip if slot object is missing
					local slotObj = plot:FindFirstChild(slotName)
					if not slotObj then
						print("PlotPersistence: Restore skip - Slot not found:", slotName, "in plot", plotName)
						-- continue to next slot
					else
						-- Skip if slot already marked Occupied
						local skipThisSlot = false
						if slotObj.GetAttribute and slotObj:GetAttribute("Occupied") then
							print("PlotPersistence: Restore skip - Slot Occupied attribute set:", slotName, "in plot", plotName)
							skipThisSlot = true
						end

						-- Skip if any existing model already claims this slot (rekursiv)
						if not skipThisSlot then
							local brainrotsFolder = workspace:FindFirstChild("Brainrots")
							if brainrotsFolder then
								for _, obj in ipairs(brainrotsFolder:GetDescendants()) do
									if obj:IsA("Model") then
										local s = obj:FindFirstChild("StoredInSlot")
										if s and s:IsA("StringValue") and s.Value == slotName then
											print("PlotPersistence: Restore skip - existing model already stored in slot:", slotName, "in plot", plotName)
											skipThisSlot = true
											break
										end
									end
								end
							end
						end

						if not skipThisSlot then
							-- Try to spawn via callback
							local ok, modelOrErr = pcall(function()
								return spawnCallback(plot, slotName, slotInfo)
							end)
							if ok and modelOrErr and startIncomeCallback then
								-- Mark StoredInSlot and Occupied on the slot object
								local s = modelOrErr:FindFirstChild("StoredInSlot") or Instance.new("StringValue")
								s.Name = "StoredInSlot"
								s.Value = slotName
								s.Parent = modelOrErr

								if slotObj.SetAttribute then
									slotObj:SetAttribute("Occupied", true)
								end

								pcall(function() startIncomeCallback(modelOrErr) end)
							else
								if not ok then
									warn("PlotPersistence: spawnCallback error for", player.Name, plotName, slotName, modelOrErr)
								end
							end
						end
					end
				end
			end
		end
	end

	return true
end

return PlotPersistence
