-- PlotPersistence.lua (ModuleScript in ServerScriptService)
-- Speichert Gold + Brainrots pro Slot. StoredInSlot = slot.Name.
-- Überarbeitet: rekursive Prüfungen, defensive Restore, debug-Ausgaben hinter DEBUG-Flag

local DataStoreService = game:GetService("DataStoreService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

local PlotPersistence = {}

-- Debug-Flag: auf true setzen, um alte Debug-prints wieder zu sehen
local DEBUG = false

local DATASTORE_NAME = "PlayerPlots_v1"
local ds = nil

local function tryGetDataStore()
	if ds then return ds end
	local inStudio = RunService:IsStudio()
	if inStudio then
		pcall(function() ds = DataStoreService:GetDataStore(DATASTORE_NAME) end)
		return ds
	else
		ds = DataStoreService:GetDataStore(DATASTORE_NAME)
		return ds
	end
end

local SAVE_RETRIES = 5
local RETRY_BASE_DELAY = 0.25

local function retryAsync(fn, retries)
	retries = retries or SAVE_RETRIES
	local delayTime = RETRY_BASE_DELAY
	for i = 1, retries do
		local ok, res = pcall(fn)
		if ok then
			return true, res
		end
		task.wait(delayTime)
		delayTime *= 2
	end
	return false, "max retries exceeded"
end

-- BuildSaveForPlayer: sammelt Slots & Gold
function PlotPersistence:BuildSaveForPlayer(player)
	local out = { Plots = {}, Gold = 0, Updated = os.time() }

	if player and player:FindFirstChild("leaderstats") then
		local gold = player.leaderstats:FindFirstChild("Gold")
		if gold and gold:IsA("IntValue") then
			out.Gold = gold.Value
		end
	end

	local plotsFolder = workspace:FindFirstChild("Plots")
	if not plotsFolder then
		warn("PlotPersistence: workspace.Plots fehlt; kein Plot-Save möglich.")
		return out
	end

	for _, plot in ipairs(plotsFolder:GetChildren()) do
		if plot and plot:IsA("Instance") then
			local ownerAttr = plot:GetAttribute("Owner")
			if ownerAttr == player.Name then
				local plotData = { Slots = {} }

				for _, slot in ipairs(plot:GetChildren()) do
					local isSlot = false
					if type(slot.Name) == "string" and slot.Name:match("^Slot") then
						isSlot = true
					elseif slot:GetAttribute("IsSlot") == true then
						isSlot = true
					elseif slot:FindFirstChild("SlotMarker") then
						isSlot = true
					end

					if isSlot then
						-- DEBUG: kontrollierte Ausgabe
						if DEBUG then
							print("DEBUG SaveScan: player=", player.Name, "plot=", plot.Name, "slot=", slot.Name)
						end

						local brainrotsFolder = workspace:FindFirstChild("Brainrots")
						local found = nil
						if brainrotsFolder then
							-- robust: rekursiv alle Descendants prüfen, nur Models berücksichtigen
							for _, obj in ipairs(brainrotsFolder:GetDescendants()) do
								if obj:IsA("Model") then
									local storedTag = obj:FindFirstChild("StoredInSlot")
									if storedTag and storedTag.Value == slot.Name then
										-- Wir nehmen nur das erste gefundene Brainrot für diesen Slot
										found = obj
										if DEBUG then
											print("DEBUG Found brainrot for slot:", slot.Name, " -> ", obj.Name)
										end
										break
									end
								end
							end
						end

						-- Wenn gefunden, packe seine Metadaten ins Save-Payload
						if found then
							local meta = {}
							local mn = found:FindFirstChild("ModelName")
							local rarity = found:FindFirstChild("Rarity")
							local mining = found:FindFirstChild("MiningPower")
							local income = found:FindFirstChild("IncomePerSec")
							meta.ModelName = (mn and mn.Value) or found.Name
							meta.Rarity = (rarity and rarity.Value) or (found:GetAttribute("Rarity") or "Common")
							meta.MiningPower = (mining and tonumber(mining.Value)) or (found:GetAttribute("MiningPower") or 0)
							meta.IncomePerSec = (income and tonumber(income.Value)) or (found:GetAttribute("IncomePerSec") or 0)
							meta.StoredInSlot = slot.Name
							plotData.Slots[slot.Name] = meta
						end
					end
				end

				out.Plots[plot.Name] = plotData
			end
		end
	end

	return out
end

-- SavePlayer: speichert Daten via DataStore (robust mit retry)
function PlotPersistence:SavePlayer(player)
	local ok, dsRef = pcall(tryGetDataStore)
	if not ok or not dsRef then
		warn("PlotPersistence: DataStore nicht verfügbar; Save übersprungen.")
		return false, "datastore unavailable"
	end

	local payload = self:BuildSaveForPlayer(player)
	local key = "player_" .. tostring(player.UserId)

	local suc, res = retryAsync(function()
		return dsRef:SetAsync(key, payload)
	end, SAVE_RETRIES)

	if not suc then
		warn("PlotPersistence: Save fehlgeschlagen:", res)
		return false, res
	end

	if DEBUG then
		print("PlotPersistence: Saved data for", player.Name)
	end
	return true
end

-- RestorePlayer: liest Daten und ruft callbacks zum Spawnen auf
-- spawnCallback(plot, slotName, slotInfo) -> Model or nil
-- startIncomeCallback(model)
function PlotPersistence:RestorePlayer(player, spawnCallback, startIncomeCallback)
	local ok, dsRef = pcall(tryGetDataStore)
	if not ok or not dsRef then
		warn("PlotPersistence: DataStore nicht verfügbar; Restore übersprungen.")
		return false, "datastore unavailable"
	end

	local key = "player_" .. tostring(player.UserId)
	local suc, data = retryAsync(function()
		return dsRef:GetAsync(key)
	end, SAVE_RETRIES)

	if not suc then
		-- Kein Save vorhanden oder Fehler
		if DEBUG then
			print("PlotPersistence: Kein Save oder Fehler beim Laden für", player.Name)
		end
		return false, "no data"
	end

	if not data or type(data) ~= "table" or not data.Plots then
		if DEBUG then
			print("PlotPersistence: Ungültige Save-Daten für", player.Name)
		end
		return false, "invalid data"
	end

	-- Stabile Restore-Logik: iteriere über gespeicherte Plots und Slots
	local plotsFolder = workspace:FindFirstChild("Plots")
	if not plotsFolder then
		warn("PlotPersistence: workspace.Plots fehlt; Restore nicht möglich.")
		return false, "no plots folder"
	end

	for plotName, plotData in pairs(data.Plots or {}) do
		local plot = plotsFolder:FindFirstChild(plotName)
		if plot then
			for slotName, slotInfo in pairs(plotData.Slots or {}) do
				local okSpawn, spawned = pcall(function()
					return spawnCallback(plot, slotName, slotInfo)
				end)
				if okSpawn and spawned then
					-- starte Einkommen (falls Callback vorhanden)
					if startIncomeCallback then
						pcall(function() startIncomeCallback(spawned) end)
					end
					if DEBUG then
						print("PlotPersistence: Restored", slotInfo.ModelName, "into", plotName, slotName)
					end
				else
					if DEBUG then
						print("PlotPersistence: Spawn-Callback gab nil für", plotName, slotName)
					end
				end
			end
		else
			if DEBUG then
				print("PlotPersistence: Plot nicht gefunden beim Restore:", plotName)
			end
		end
	end

	-- Gold wiederherstellen (sofern leaderstats vorhanden)
	if data.Gold and player:FindFirstChild("leaderstats") then
		local gold = player.leaderstats:FindFirstChild("Gold")
		if gold and gold:IsA("IntValue") then
			gold.Value = tonumber(data.Gold) or gold.Value
			if DEBUG then
				print("PlotPersistence: Gold restored for", player.Name, gold.Value)
			end
		end
	end

	return true
end

return PlotPersistence
