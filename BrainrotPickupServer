-- BrainrotPickupServer.lua (ServerScriptService)
-- Vollständige, robuste Version mit Inventory-Integration und standardisierten Client-Antworten
-- Debug-prints sind hinter DEBUG flag versteckt; Logik weitgehend unverändert, aber
-- einige Ausdrücke wurden expliziter geschrieben, um Parser-Probleme zu vermeiden.

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local RunService = game:GetService("RunService")

-- Debug-Flag: auf true setzen, um detailreiche Server-Logs zu sehen
local DEBUG = true

-- Module requires (erwartet im ServerScriptService vorhanden)
local Inventory = require(game.ServerScriptService:WaitForChild("InventoryServer"))
local Catalog = require(game.ServerScriptService:WaitForChild("AssetCatalog"))

-- Remotes (erzeugt falls nicht vorhanden)
local function ensureRemote(name)
	local r = ReplicatedStorage:FindFirstChild(name)
	if not r then
		r = Instance.new("RemoteEvent")
		r.Name = name
		r.Parent = ReplicatedStorage
	end
	return r
end

local pickupRemote = ensureRemote("BrainrotPickup")
local placeRemote = ensureRemote("BrainrotPlace")
local equipReq = ensureRemote("EquipRequest")
local equipResp = ensureRemote("EquipResponse")

-- Folders
local brainrotsFolder = workspace:FindFirstChild("Brainrots")
if not brainrotsFolder then
	error("Brainrots folder missing in workspace")
end

local heldStorage = workspace:FindFirstChild("HeldBrainrots")
if not heldStorage then
	heldStorage = Instance.new("Folder")
	heldStorage.Name = "HeldBrainrots"
	heldStorage.Parent = workspace
end

-- State
local heldByPlayer = {}      -- userId -> { model = Model, meta = metaTable, invIndex = number? }
local activeIncome = {}      -- model -> income runner

-- Cooldown to reduce rapid double-places
local placeCooldown = {}
local PLACE_COOLDOWN_SEC = 0.5

-- Utility: store original transparencies/anchored states
local function storeOriginalTransparencies(model)
	local meta = { partOrigTransparency = {}, anchoredStates = {}, originalParent = model.Parent }
	for _, p in ipairs(model:GetDescendants()) do
		if p:IsA("BasePart") then
			meta.partOrigTransparency[p] = p.Transparency or 0
			meta.anchoredStates[p] = p.Anchored
		end
	end
	return meta
end

local function restoreTransparenciesAndAnchors(meta)
	if not meta then return false end
	local ok = true
	for part, orig in pairs(meta.partOrigTransparency or {}) do
		if part and part.Parent then
			local success, err = pcall(function() part.Transparency = orig or 0 end)
			if not success then ok = false; warn("restore transparency failed:", err) end
		end
	end
	for part, anchored in pairs(meta.anchoredStates or {}) do
		if part and part.Parent then
			local success, err = pcall(function() part.Anchored = anchored end)
			if not success then ok = false; warn("restore anchored failed:", err) end
		end
	end
	return ok
end

-- Income loop for placed models
local function startIncomeForPlaced(model)
	if not model or not model.Parent then return end
	if activeIncome[model] then return end

	local incomeValObj = model:FindFirstChild("IncomePerSec")
	local ownerVal = model:FindFirstChild("Owner")
	if not incomeValObj or not ownerVal then return end

	local incomePerSec = tonumber(incomeValObj.Value) or 0
	local ownerName = tostring(ownerVal.Value or "")

	local conn = {}
	activeIncome[model] = conn

	-- simple loop: accrue gold to owner every second
	conn.runner = task.spawn(function()
		while model and model.Parent and activeIncome[model] == conn do
			if incomePerSec > 0 and ownerName ~= "" then
				local player = Players:FindFirstChild(ownerName)
				if player and player:FindFirstChild("leaderstats") and player.leaderstats:FindFirstChild("Gold") then
					local goldVal = player.leaderstats.Gold
					goldVal.Value = goldVal.Value + incomePerSec
				end
			end
			task.wait(1)
		end
	end)
end

local function stopIncomeForPlaced(model)
	if activeIncome[model] then
		-- stop runner by clearing table entry; runner will exit naturally
		activeIncome[model] = nil
	end
end

-- Helper: resolve slot instance or name
local function resolveSlot(plot, slotInstanceOrName)
	if typeof(slotInstanceOrName) == "Instance" then
		return slotInstanceOrName
	elseif type(slotInstanceOrName) == "string" then
		return plot and plot:FindFirstChild(slotInstanceOrName)
	end
	return nil
end

-- Server pickup handler: purchase or pickup placed
pickupRemote.OnServerEvent:Connect(function(player, targetOrName)
	-- targetOrName may be nil, an Instance (placed brainrot) or a ModelName (string) to buy
	-- Validate player state
	local uid = player.UserId

	-- If player already holds a brainrot in heldByPlayer, deny pickup/buy
	if heldByPlayer[uid] then
		pickupRemote:FireClient(player, false, "Du hältst bereits ein Brainrot.")
		return
	end

	-- If targetOrName is an Instance and is a placed brainrot inside workspace.Brainrots
	if typeof(targetOrName) == "Instance" then
		local model = targetOrName
		-- Validate ownership / StoredInSlot
		if model:IsDescendantOf(brainrotsFolder) and model:FindFirstChild("StoredInSlot") then
			local owner = model:FindFirstChild("Owner")
			if not owner or owner.Value ~= player.Name then
				pickupRemote:FireClient(player, false, "Nicht dein Brainrot.")
				return
			end

			-- Free slot Occupied attribute
			local stored = model:FindFirstChild("StoredInSlot")
			if stored and stored.Value and stored.Value ~= "" then
				local plotsFolder = workspace:FindFirstChild("Plots")
				if plotsFolder then
					for _, plot in ipairs(plotsFolder:GetChildren()) do
						local slotObj = plot:FindFirstChild(stored.Value)
						if slotObj and slotObj.SetAttribute then
							slotObj:SetAttribute("Occupied", nil)
							break
						end
					end
				end
				pcall(function() stored:Destroy() end)
			end

			-- Park in HeldBrainrots (visuals transparent)
			local meta = storeOriginalTransparencies(model)
			local okPark, parkErr = pcall(function()
				for _, part in ipairs(model:GetDescendants()) do
					if part:IsA("BasePart") then
						part.CanCollide = false
						part.Anchored = true
						part.Transparency = 1
					end
				end
				model.Parent = heldStorage
			end)
			if not okPark then
				warn("Pickup: Fehler beim Parken:", parkErr)
				pickupRemote:FireClient(player, false, "Aufnahme fehlgeschlagen.")
				return
			end

			heldByPlayer[uid] = { model = model, meta = meta }
			pickupRemote:FireClient(player, true, "pickedUp")
			if DEBUG then
				print(player.Name .. " picked up placed " .. model.Name)
			end
			return
		end
	end

	-- Otherwise: treat targetOrName as a purchase of a model name (string)
	local modelName = tostring(targetOrName or "")
	-- Validate model exists in Catalog or ReplicatedStorage models
	local def = Catalog[modelName] or {}
	local leaderstats = player:FindFirstChild("leaderstats")
	local gold = leaderstats and leaderstats:FindFirstChild("Gold")

	-- Compute cost explicitly to avoid ambiguous inline expressions
	local cost = 0
	if def and def.Price then
		cost = def.Price
	elseif def and def.MiningPower then
		-- ensure numeric
		local mp = tonumber(def.MiningPower) or def.MiningPower or 0
		cost = tonumber(mp) * 5
	else
		cost = 0
	end

	if not gold then
		pickupRemote:FireClient(player, false, "Fehlende Daten.")
		return
	end
	if gold.Value < cost then
		pickupRemote:FireClient(player, false, "Brauchst " .. tostring(cost) .. " Gold!")
		return
	end

	-- Bezahlen
	gold.Value = gold.Value - cost

	-- Erzeuge Inventory Item (Metadaten)
	local item = {
		ModelName = modelName,
		Rarity = def.Rarity or "Common",
		MiningPower = def.MiningPower or 0,
		IncomePerSec = def.IncomePerSec or 0,
	}

	-- Füge zum Inventory Server-seitig hinzu
	local addedOk, err = pcall(function()
		Inventory:AddToInventory(player, item)
	end)
	if not addedOk then
		warn("Pickup/Buys: Inventory add failed:", err)
		pickupRemote:FireClient(player, false, "Fehler beim Hinzufügen zum Inventar.")
		return
	end

	pickupRemote:FireClient(player, true, "addedToInventory")
	if DEBUG then
		print("Player", player.Name, "bought", modelName, "for", cost)
	end
end)

-- Server place handler: place a held brainrot into a slot
placeRemote.OnServerEvent:Connect(function(player, slotInstanceOrName)
	local uid = player.UserId
	-- validate cooldown
	local lastPlace = placeCooldown[uid] or 0
	if tick() - lastPlace < PLACE_COOLDOWN_SEC then
		placeRemote:FireClient(player, false, "Bitte kurz warten.")
		return
	end
	placeCooldown[uid] = tick()

	local held = heldByPlayer[uid]
	if not held or not held.model then
		placeRemote:FireClient(player, false, "Du hältst nichts.")
		return
	end

	-- find player's plot
	local plotName = player:GetAttribute("PlotName")
	if not plotName then
		placeRemote:FireClient(player, false, "Kein Plot gefunden.")
		return
	end
	local plotsFolder = workspace:FindFirstChild("Plots")
	if not plotsFolder then
		placeRemote:FireClient(player, false, "Plots nicht verfügbar.")
		return
	end
	local plot = plotsFolder:FindFirstChild(plotName)
	if not plot then
		placeRemote:FireClient(player, false, "Plot nicht gefunden.")
		return
	end

	local slot = resolveSlot(plot, slotInstanceOrName)
	if not slot then
		placeRemote:FireClient(player, false, "Slot nicht gefunden.")
		return
	end

	-- Check Occupied attribute
	local occupied = nil
	if slot.GetAttribute then
		occupied = slot:GetAttribute("Occupied")
	end
	if occupied then
		placeRemote:FireClient(player, false, "Slot bereits belegt.")
		return
	end

	-- Perform placement: restore visuals, parent into workspace Brainrots, set StoredInSlot & Owner, mark slot Occupied
	local model = held.model
	local meta = held.meta
	-- restore transparency/anchored
	pcall(function() restoreTransparenciesAndAnchors(meta) end)
	-- set model position to slot position (approx above slot)
	if slot and slot:IsA("BasePart") and model.PrimaryPart then
		model:SetPrimaryPartCFrame(slot.CFrame * CFrame.new(0, 3, 0))
	elseif slot and slot:IsA("BasePart") then
		-- try to position first BasePart (defensive)
		for _, p in ipairs(model:GetDescendants()) do
			if p:IsA("BasePart") then
				p.CFrame = slot.CFrame * CFrame.new(0, 3, 0)
				break
			end
		end
	end
	-- set parent to workspace Brainrots
	model.Parent = brainrotsFolder

	-- set StoredInSlot tag
	local stored = model:FindFirstChild("StoredInSlot")
	if not stored then
		stored = Instance.new("StringValue")
		stored.Name = "StoredInSlot"
		stored.Parent = model
	end
	stored.Value = slot.Name

	-- set Owner
	local ownerTag = model:FindFirstChild("Owner")
	if not ownerTag then
		ownerTag = Instance.new("StringValue")
		ownerTag.Name = "Owner"
		ownerTag.Value = player.Name
		ownerTag.Parent = model
	else
		ownerTag.Value = player.Name
	end

	-- mark slot occupied attribute
	if slot.SetAttribute then
		slot:SetAttribute("Occupied", true)
	end

	-- clear held state
	heldByPlayer[uid] = nil

	-- start income for model if applicable
	pcall(function() startIncomeForPlaced(model) end)

	placeRemote:FireClient(player, true, tostring(model.Name))
	if DEBUG then
		print("Placed model", model.Name, "into slot", slot.Name, "for", player.Name)
	end
end)

-- Equip request handler (equip from inventory into HeldBrainrots)
equipReq.OnServerEvent:Connect(function(player, inventoryIndex)
	-- Inventory module should handle equipping, spawning model in HeldBrainrots, and returning model instance
	local ok, result = pcall(function()
		return Inventory:EquipFromInventory(player, inventoryIndex, heldStorage)
	end)
	if ok and result and typeof(result) == "Instance" then
		-- Parked into heldStorage by Inventory: set heldByPlayer
		heldByPlayer[player.UserId] = { model = result, meta = storeOriginalTransparencies(result) }
		equipResp:FireClient(player, true, "equipped")
		if DEBUG then
			print("Equip success for", player.Name)
		end
	else
		local err = tostring(result)
		equipResp:FireClient(player, false, err or "Equip failed")
		if DEBUG then
			print("Equip failed for", player.Name, err)
		end
	end
end)
