-- RollSystem.lua (ServerScriptService)
-- Nutzt AssetCatalog als Quelle f√ºr Brainrot-Definitionen (Price/MiningPower/Income/Rarity)
-- F√ºgt ProximityPrompt zum Kaufen hinzu (Client feuert BrainrotPickup mit Modelname)
-- Exposes _G.spawnBrainrotModel f√ºr PersistenceInit

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local plotsFolder = workspace:WaitForChild("Plots")
local ROLL_COST = 2 -- testing value; bei Bedarf anpassen
local math_random = math.random

local brainrotsFolder = workspace:FindFirstChild("Brainrots")
if not brainrotsFolder then
	brainrotsFolder = Instance.new("Folder")
	brainrotsFolder.Name = "Brainrots"
	brainrotsFolder.Parent = workspace
end

local modelsFolder = ReplicatedStorage:FindFirstChild("BrainrotModels")
local workspaceModelsFolder = workspace:FindFirstChild("Brainrots") and workspace.Brainrots:FindFirstChild("Brainrot pack1")

local PRICE_MULTIPLIER = 5 -- Fallback, falls kein Price im Catalog

-- Single Source: AssetCatalog
local Catalog = require(game.ServerScriptService:WaitForChild("AssetCatalog"))

-- Definitions auf Basis des Catalog
local brainrotDefinitions = {}
for name, def in pairs(Catalog) do
	brainrotDefinitions[name] = {
		ModelName    = def.TemplateName or name,
		DisplayName  = name,
		Rarity       = def.Rarity or "Common",
		MiningPower  = def.MiningPower or 1,
		IncomePerSec = def.IncomePerSec or math.max(1, math.floor((def.MiningPower or 1) * 0.5)),
		Price        = def.Price or math.floor((def.MiningPower or 1) * PRICE_MULTIPLIER),
	}
end

local rarityWeights = {
	Common    = 60,
	Uncommon  = 25,
	Rare      = 10,
	Legendary = 4,
	Mythic    = 1,
}

local rarityColors = {
	Common    = Color3.fromRGB(200,200,200),
	Uncommon  = Color3.fromRGB(100,220,120),
	Rare      = Color3.fromRGB(100,160,255),
	Legendary = Color3.fromRGB(255,180,60),
	Mythic    = Color3.fromRGB(230,80,230),
}

local function pickRarityByWeight()
	local total = 0
	for _, w in pairs(rarityWeights) do total += w end
	local pick = math_random(1, total)
	local acc = 0
	for r, w in pairs(rarityWeights) do
		acc += w
		if pick <= acc then return r end
	end
	return "Common"
end

local function pickDefinitionByRarity(rarity)
	local list = {}
	for name, def in pairs(brainrotDefinitions) do
		if def.Rarity == rarity then
			table.insert(list, { Name = name, Def = def })
		end
	end
	if #list == 0 then return nil end
	return list[math_random(1, #list)]
end

local function rollDefinition()
	local rarity = pickRarityByWeight()
	local picked = pickDefinitionByRarity(rarity)
	if picked then return picked.Name, picked.Def end
	for name, def in pairs(brainrotDefinitions) do return name, def end
end

local function getPlotPosition(plot)
	local spawnPart = plot:FindFirstChild("BrainrotSpawn")
	if spawnPart and spawnPart:IsA("BasePart") then
		return spawnPart.Position + Vector3.new(0, 0.6, 0)
	end
	warn("‚ö†Ô∏è Plot " .. plot.Name .. " hat keinen BrainrotSpawn! Fallback wird verwendet.")
	local playerSpawn = plot:FindFirstChild("Spawn")
	if playerSpawn and playerSpawn:IsA("BasePart") then
		return playerSpawn.Position + Vector3.new(0, 5, 0)
	end
	if plot.PrimaryPart then
		return plot.PrimaryPart.Position + Vector3.new(0, 5, 0)
	end
	for _, c in ipairs(plot:GetDescendants()) do
		if c:IsA("BasePart") then
			return c.Position + Vector3.new(0, 5, 0)
		end
	end
	return nil
end

local function findTemplate(modelName)
	if modelsFolder then
		local t = modelsFolder:FindFirstChild(modelName)
		if t then return t end
	end
	if workspaceModelsFolder then
		local t = workspaceModelsFolder:FindFirstChild(modelName)
		if t then return t end
	end
	return nil
end

local function ensurePrompt(model, def)
	if not model then return end
	local primary = model.PrimaryPart
	if not primary then
		for _, c in ipairs(model:GetDescendants()) do
			if c:IsA("BasePart") then
				model.PrimaryPart = c
				primary = c
				break
			end
		end
	end
	if not primary then return end

	local prompt = primary:FindFirstChild("BrainrotPurchase")
	if not prompt then
		prompt = Instance.new("ProximityPrompt")
		prompt.Name = "BrainrotPurchase"
		prompt.ActionText = "Kaufen"
		prompt.ObjectText = tostring(def.Price or 0) .. " Gold"
		prompt.HoldDuration = 0.75
		prompt.MaxActivationDistance = 12
		prompt.RequiresLineOfSight = false
		prompt.Exclusivity = Enum.ProximityPromptExclusivity.OnePerButton
		prompt.Parent = primary
	end
	prompt:SetAttribute("ModelName", def.DisplayName or model.Name)
	prompt.ObjectText = tostring(def.Price or 0) .. " Gold"
end

local function attachLabelToModel(model, displayName, rarityName, price, incomePerSec)
	if not model then return end
	local primary = model.PrimaryPart
	if not primary then
		for _, c in ipairs(model:GetDescendants()) do
			if c:IsA("BasePart") then
				model.PrimaryPart = c
				primary = c
				break
			end
		end
	end
	if not primary then return end

	local old = primary:FindFirstChild("BrainrotLabel")
	if old then old:Destroy() end

	local size = model:GetExtentsSize()
	local heightBoost = math.clamp(size.Y * 0.6, 3, 12)

	local bb = Instance.new("BillboardGui")
	bb.Name = "BrainrotLabel"
	bb.Adornee = primary
	bb.AlwaysOnTop = true
	bb.Size = UDim2.new(0, 200, 0, 90)
	bb.StudsOffset = Vector3.new(0, heightBoost, 0)
	bb.MaxDistance = 150
	bb.LightInfluence = 0
	bb.Parent = primary

	local function makeLine(text, order, color)
		local lbl = Instance.new("TextLabel")
		lbl.Size = UDim2.new(1, 0, 0, 18)
		lbl.Position = UDim2.new(0, 0, 0, order * 18)
		lbl.BackgroundTransparency = 1
		lbl.Text = text
		lbl.Font = Enum.Font.GothamBold
		lbl.TextSize = 14
		lbl.TextColor3 = color or Color3.fromRGB(255,255,255)
		lbl.TextXAlignment = Enum.TextXAlignment.Center
		lbl.Parent = bb

		local stroke = Instance.new("UIStroke")
		stroke.Thickness = 2
		stroke.Color = Color3.fromRGB(0,0,0)
		stroke.Parent = lbl
	end

	makeLine(tostring(rarityName), 0, rarityColors[rarityName] or Color3.fromRGB(255,255,255))
	makeLine(tostring(displayName), 1)
	makeLine("Preis: " .. tostring(price), 2)
	makeLine("Income: " .. tostring(incomePerSec) .. "/s", 3)
end

local function spawnBrainrotModel(modelName, displayName, def, ownerName, spawnPos)
	local template = findTemplate(modelName)
	if not template then
		warn("RollSystem: Template fehlt:", modelName)
		return nil
	end

	local clone = template:Clone()
	clone.Name = displayName or template.Name

	if not clone.PrimaryPart then
		for _, c in ipairs(clone:GetDescendants()) do
			if c:IsA("BasePart") then
				clone.PrimaryPart = c
				break
			end
		end
	end
	if not clone.PrimaryPart then
		local p = Instance.new("Part")
		p.Name = "Primary"
		p.Size = Vector3.new(1,1,1)
		p.Transparency = 1
		p.CanCollide = false
		p.Anchored = true
		p.Parent = clone
		clone.PrimaryPart = p
	end

	local finalPos = spawnPos + Vector3.new(0, 1.5, 0)
	clone:SetPrimaryPartCFrame(CFrame.new(finalPos))

	local mining = def.MiningPower or 1
	local price = def.Price or math.floor(mining * PRICE_MULTIPLIER)
	local income = def.IncomePerSec or math.max(1, math.floor(mining * 0.5))
	local rarity = def.Rarity or "Common"

	local ownerVal = Instance.new("StringValue"); ownerVal.Name = "Owner"; ownerVal.Value = ownerName; ownerVal.Parent = clone
	local powerVal = Instance.new("IntValue"); powerVal.Name = "MiningPower"; powerVal.Value = mining; powerVal.Parent = clone
	local rarityVal = Instance.new("StringValue"); rarityVal.Name = "Rarity"; rarityVal.Value = rarity; rarityVal.Parent = clone
	local priceVal = Instance.new("IntValue"); priceVal.Name = "Price"; priceVal.Value = price; priceVal.Parent = clone
	local incomeVal = Instance.new("IntValue"); incomeVal.Name = "IncomePerSec"; incomeVal.Value = income; incomeVal.Parent = clone

	clone.Parent = brainrotsFolder

	local anchoredParts = {}
	for _, p in ipairs(clone:GetDescendants()) do
		if p:IsA("BasePart") then
			anchoredParts[p] = p.Anchored
			p.Anchored = true
			p.CanCollide = true
		end
	end

	task.spawn(function()
		local parts = {}
		for _, d in ipairs(clone:GetDescendants()) do
			if d:IsA("BasePart") then
				table.insert(parts, d)
			end
		end
		local orig = {}
		for _, p in ipairs(parts) do orig[p] = p.Transparency; p.Transparency = 1 end

		local steps = 8
		for i = 1, steps do
			local t = i / steps
			for _, p in ipairs(parts) do
				local o = orig[p] or 0
				p.Transparency = o + (1 - o) * (1 - t)
			end
			task.wait(0.03)
		end
		for _, p in ipairs(parts) do p.Transparency = orig[p] or 0 end

		task.wait(0.05)
		for p, old in pairs(anchoredParts) do
			if p and p.Parent then
				p.Anchored = false
			end
		end
	end)

	attachLabelToModel(clone, displayName or clone.Name, rarity, price, income)
	ensurePrompt(clone, def)

	return clone
end

-- Expose f√ºr PersistenceInit
_G.spawnBrainrotModel = spawnBrainrotModel

print("üîç RollSystem ready")

for _, plot in ipairs(plotsFolder:GetChildren()) do
	local rollButton = plot:FindFirstChild("RollButton") or plot:FindFirstChild("GachaButton", true)
	if not rollButton then continue end

	local cd = rollButton:FindFirstChildOfClass("ClickDetector")
	if not cd then
		warn("RollButton ohne ClickDetector:", plot.Name)
		continue
	end

	local debounce = {}

	cd.MouseClick:Connect(function(player)
		if debounce[player.UserId] then return end
		debounce[player.UserId] = true
		task.delay(0.3, function() debounce[player.UserId] = nil end)

		-- Klick-Sound
		local soundsFolder = ReplicatedStorage:FindFirstChild("Sounds")
		if soundsFolder then
			local clickSoundTemplate = soundsFolder:FindFirstChild("Click")
			if clickSoundTemplate and clickSoundTemplate:IsA("Sound") then
				local s = clickSoundTemplate:Clone()
				s.Parent = rollButton
				pcall(function() s:Play() end)
				game:GetService("Debris"):AddItem(s, 2)
			end
		end

		local owner = plot:GetAttribute("Owner")
		if not owner or owner ~= player.Name then return end

		local stats = player:FindFirstChild("leaderstats")
		local gold = stats and stats:FindFirstChild("Gold")
		if not gold or gold.Value < ROLL_COST then return end

		gold.Value = gold.Value - ROLL_COST

		local pos = getPlotPosition(plot)
		if not pos then
			warn("RollSystem: Keine g√ºltige Spawn-Position f√ºr Plot " .. plot.Name)
			return
		end

		for _, obj in ipairs(brainrotsFolder:GetChildren()) do
			local part = obj:IsA("Model") and obj.PrimaryPart or obj
			if part and part:IsA("BasePart") then
				local o = obj:FindFirstChild("Owner")
				local stored = obj:FindFirstChild("StoredInSlot")
				if o and o.Value == player.Name and not stored then
					if (part.Position - pos).Magnitude < 50 then
						obj:Destroy()
					end
				end
			end
		end

		local name, def = rollDefinition()
		if not def then
			warn("RollSystem: Keine Brainrot-Definition gefunden.")
			return
		end

		local spawnPos = pos + Vector3.new(0, 0.5, 0)
		local spawned = spawnBrainrotModel(def.ModelName, name, def, player.Name, spawnPos)
		if spawned then
			print("üé≤ " .. player.Name .. " rolled " .. tostring(name) .. " [" .. tostring(def.Rarity or "Common") .. "] Power:" .. tostring(def.MiningPower))
		else
			warn("RollSystem: Spawn fehlgeschlagen f√ºr " .. tostring(name))
		end
	end)
end

print("‚úÖ RollSystem live")
