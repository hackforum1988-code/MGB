-- PlotManagerAPI.lua (ModuleScript in ServerScriptService)
-- Funktionen:
--   PlaceInSlot(player, slotName, brainrotId) -> returns (true, reason?) on success
--   RemoveFromSlot(player, slotName) -> returns (true, reason?) on success
-- Hinweis: erwartet Slot-Parts unter workspace.Plots.<PlotName>.<SlotName>
-- und ein ServerStorage.PurchasedBrainrots Folder (wird bei Bedarf erzeugt).

local PlotManagerAPI = {}
local ServerStorage = game:GetService("ServerStorage")
local Workspace = game:GetService("Workspace")

local PERSIST_MODULE_NAME = "PlotPersistence" -- sollte in ServerScriptService existieren
local PURCHASE_ARCHIVE_FOLDER = "PurchasedBrainrots"

local function dbg(...)
	print("[PlotManagerAPI]", ...)
end

local function getPlayerPlot(player)
	-- Versucht zuerst PlotName-Attribute am Player (wie PlotManager setzt)
	local plotName = player:GetAttribute("PlotName")
	if plotName and Workspace:FindFirstChild("Plots") then
		local plot = Workspace.Plots:FindFirstChild(plotName)
		if plot then return plot end
	end
	-- Fallback: suche Plot mit Owner==player.Name
	if Workspace:FindFirstChild("Plots") then
		for _, p in ipairs(Workspace.Plots:GetChildren()) do
			if p:GetAttribute("Owner") == player.Name then
				return p
			end
		end
	end
	return nil
end

local function findSlotInPlayerPlot(player, slotName)
	local plot = getPlayerPlot(player)
	if not plot then return nil, "NoPlot" end
	local slot = plot:FindFirstChild(slotName)
	if not slot then return nil, "NoSuchSlot" end
	return slot
end

local function findArchivedById(brainrotId)
	local folder = ServerStorage:FindFirstChild(PURCHASE_ARCHIVE_FOLDER)
	if not folder then return nil end
	for _, child in ipairs(folder:GetChildren()) do
		-- archived names may contain id suffix, or attribute BrainrotId
		if child:GetAttribute("BrainrotId") == brainrotId then
			return child
		end
		if tostring(child.Name):find(tostring(brainrotId)) then
			return child
		end
	end
	return nil
end

local function findWorkspaceBrainrotBySlot(plotSlot, player)
	-- Suche in workspace.Brainrots nach einem Model mit StoredInSlot == slot.Name und Owner == player.Name
	local brainrotsFolder = Workspace:FindFirstChild("Brainrots")
	if not brainrotsFolder then return nil end
	for _, obj in ipairs(brainrotsFolder:GetDescendants()) do
		if obj:IsA("Model") then
			local stored = obj:GetAttribute("StoredInSlot")
			local owner = obj:GetAttribute("Owner")
			if stored == plotSlot.Name and owner == player.Name then
				return obj
			end
		end
	end
	return nil
end

function PlotManagerAPI.PlaceInSlot(player, slotName, brainrotId)
	-- Returns true on success, false + reason on fail
	if not player then return false, "invalid player" end
	local slot, err = findSlotInPlayerPlot(player, slotName)
	if not slot then return false, err or "no slot" end

	-- check if slot already occupied
	local occupied = findWorkspaceBrainrotBySlot(slot, player)
	if occupied then
		return false, "slot occupied"
	end

	-- find archived model by id in ServerStorage.PurchasedBrainrots
	local archived = findArchivedById(brainrotId)
	if not archived then
		return false, "archived brainrot not found"
	end

	-- clone archived into workspace.Brainrots as placed model
	local brainrotsFolder = Workspace:FindFirstChild("Brainrots")
	if not brainrotsFolder then
		brainrotsFolder = Instance.new("Folder")
		brainrotsFolder.Name = "Brainrots"
		brainrotsFolder.Parent = Workspace
	end

	local placed = archived:Clone()
	placed.Name = archived.Name -- keep name
	placed.Parent = brainrotsFolder

	-- set attributes so persistence sees it
	placed:SetAttribute("StoredInSlot", slot.Name)
	placed:SetAttribute("Owner", player.Name)
	-- optionally clear Owned flag? Keep Owned = true to indicate purchased
	placed:SetAttribute("Owned", true)
	-- Position model at slot if slot is BasePart or has a placement marker
	local slotPosPart = nil
	if slot:IsA("BasePart") then slotPosPart = slot end
	if not slotPosPart then
		slotPosPart = slot:FindFirstChild("Placement") or slot:FindFirstChildWhichIsA("BasePart")
	end
	local modelPrimary = placed.PrimaryPart or (placed:FindFirstChildWhichIsA("BasePart"))
	if modelPrimary and slotPosPart then
		pcall(function()
			modelPrimary.CFrame = slotPosPart.CFrame
		end)
	end

	-- Save player data via PlotPersistence if available
	local ok, PlotPersistence = pcall(function() return require(game.ServerScriptService:WaitForChild(PERSIST_MODULE_NAME)) end)
	if ok and PlotPersistence and type(PlotPersistence.SavePlayer) == "function" then
		pcall(function() PlotPersistence:SavePlayer(player) end)
	end

	dbg("Placed brainrot", placed.Name, "into", slot:GetFullName(), "for", player.Name)
	return true
end

function PlotManagerAPI.RemoveFromSlot(player, slotName)
	if not player then return false, "invalid player" end
	local slot, err = findSlotInPlayerPlot(player, slotName)
	if not slot then return false, err or "no slot" end

	local model = findWorkspaceBrainrotBySlot(slot, player)
	if not model then
		return false, "no brainrot in slot"
	end

	-- clear stored attributes so PlotPersistence no longer reports it in that slot.
	model:SetAttribute("StoredInSlot", nil)
	-- keep owner / Owned state, as it belongs to player; we'll hand it back to player's inventory through pickup flow.
	-- Optionally move to archive or keep in workspace for pickup flow. We'll keep it in workspace (pickup flow will handle giving tool).

	-- Save persistence
	local ok, PlotPersistence = pcall(function() return require(game.ServerScriptService:WaitForChild(PERSIST_MODULE_NAME)) end)
	if ok and PlotPersistence and type(PlotPersistence.SavePlayer) == "function" then
		pcall(function() PlotPersistence:SavePlayer(player) end)
	end

	dbg("Removed brainrot from slot", slotName, "for", player.Name)
	return true
end

return PlotManagerAPI
